

\paragraph{}My thesis has focused on web applications with SQL-based database backend.  I believe similar cross-stack performance and correctness problems widely exist in general big-data software --- any software  maintains and processes a large amount of data, which are stored in either SQL or non-SQL data stores under various setting including centralized computing, high performance computing, or high performance computing. My future research goal is to continue to improve the performance and correctness of big-data software through different stages of software development: design, coding, testing, and maintenance. I believe achieving this requires better interactions between developers and software, which involves inter-disciplinary solutions: software engineering, programming language, database, etc. \shan{in this paragraph, you probably want to define ``big data software'' and explain that although your ph.d. work only looked at web applications with SQL-based DB backend. you believe many problems are shared
by other big data software --- any software that maintains and process a 
large amount of data, which are stored in either sql or non-sql data stores
in a centralized computing setting or in high performance computing or distributed computing setting. you can also extend to talk about any
system that is layered, with semantic gaps and performance gaps. A VERY
important thing for you is to jump out of your ph.d. thesis and think broad.}

\paragraph{\textbf{View-Driven application design framework.}}
\shan{I changed your "web design" to "application design". better extend this to not just web design but also other big-data applications: any user-facing applications where data processing is a big performance bottleneck that can benefit from cross-stack optimization.}
Panorama is the first attempt to apply view-driven optimization by synthesizing efficient web interface designs for developers facing performance and functionality trade-offs. However the view-design optimizations provided and the interactions between developers are still limited. I believe a view-driven application design framework utilizing developers' domain-specific knowledge is necessary to construct efficient applications from the design stage.  The framework will enable developers to drag and drop the view components and assign priority label to the components. The priority label is to indicate those that should be rendered first. The application logic behind the view component could be directly written by the developers or even synthesized by the framework through input/output examples provided by the developers. Given the priority and resource budget (e.g. memory), the framework will automatically analyze the code to devise a plan to render each of the pages in the application, with the goal to reduce the time of the high priority elements as much as possible by incorporating existing optimizations we have explored. At the same time, the framework should be open to new optimization techniques by exposing the analysis framework for easy integration. I believe this framework will benefit any user-facing applications where data processing is performance bottleneck. %For the correctness purpose, the framework hides the details of implementations of data processing and the implementation of functionalities that needs to be implemented across multiple layers like data constraints to avoid correctness problems. 


\paragraph{\textbf{Improving performance using data constraints.}}
While studying the data constraints for the software correctness, I  found that constraints could also be used to improve the performance. For example, an inclusion constraint which ensures the values of a field are included in a given set indicates that the field can be stored as an ENUM type in the database which both saves the space and speeds up the query time. I will study the real-world applications' source code to extract more patterns of inferring performance optimization from data constraints. Based on the patterns, I will build static analysis tools to systematically detect the optimization opportunities using the existing data constraints. 




\paragraph{\textbf{Program synthesis for big-data analytics.}} Data analytics becomes increasingly important in
big data applications. While the ultimate goal is to subset large amounts of
data to extract insights, a study~\cite{janitor} claims that a typical data scientist spends 50-80\% of their time performing  so-called ``janitor work'' of data science, which includes tasks such as data reshaping, cleaning, and imputing (i.e., filling missing entries). Previous work tries to solve this problem~\cite{wang2017synthesizing} by synthesizing the data preparation from input/output example, however, this approach requires the output example to be partially evaluated from the input data, which still requires non-trivial efforts and often are not-feasible. Also, it does not scale well on large input files. I believe there is still a long way to go to boost the productivity of data scientists by program synthesis. I plan to apply my experience in synthesizing complex data pipelines from Juypter notebooks by target to provide support for big-data analytics through different stages including data preparation, data visualization, etc. 



\paragraph{\textbf{Improving the Correctness of Cloud Computing Systems. }}

Cloud computing systems and web applications share some properties. For example, they all need to manage large amount of data and the communication among different components could result in data maintenance problems. At the same time, distributed systems consist of more components, involve in more channel for data generation including node message and persistent file, and often go through rolling upgrade with nodes of multiple versions
communicating  altogether, which makes data maintenance in cloud computing systems harder and subtler. I believe the essence of data maintenance bugs is the same in distributed systems and in web applications. I will employ my experience in detecting and fixing data maintenance problems  in web applications to improve the correctness of cloud computing systems.  